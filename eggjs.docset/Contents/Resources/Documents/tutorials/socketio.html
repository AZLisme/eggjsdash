
    <html>
        <head>
            <title>Socket.IO</title>
            <meta charset="UTF-8">
            <link rel="stylesheet" href="../index.css">
        </head>
        <body>
        <article class="markdown-body">
    <h1>Socket.IO</h1>
    <p><strong>Socket.IO</strong> 是一个基于 Node.js 的实时应用程序框架，在即时通讯、通知与消息推送，实时分析等场景中有较为广泛的应用。</p>
<p>WebSocket 的产生源于 Web 开发中日益增长的实时通信需求，对比基于 http 的轮询方式，它大大节省了网络带宽，同时也降低了服务器的性能消耗； <a href="https://socket.io" target="_blank" rel="noopener">socket.io</a> 支持 websocket、polling 两种数据传输方式以兼容浏览器不支持 WebSocket 场景下的通信需求。</p>
<p>框架提供了 <a href="https://github.com/eggjs/egg-socket.io" target="_blank" rel="noopener">egg-socket.io</a> 插件，增加了以下开发规约：</p>
<ul>
<li>namespace: 通过配置的方式定义 namespace（命名空间）</li>
<li>middleware: 对每一次 socket 连接的建立/断开、每一次消息/数据传递进行预处理</li>
<li>controller: 响应 socket.io 的 event 事件</li>
<li>router: 统一了 socket.io 的 event 与 框架路由的处理配置方式</li>
</ul>
<h2 id="安装-egg-socketio"><a class="markdown-anchor" href="#安装-egg-socketio">#</a> 安装 egg-socket.io</h2>
<h3 id="安装"><a class="markdown-anchor" href="#安装">#</a> 安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i egg-socket.io --save</span><br/></pre></td></tr></table></figure>
<p><strong>开启插件：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/config/plugin.js</span></span><br/><span class="line">exports.io = {</span><br/><span class="line">  enable: <span class="literal">true</span>,</span><br/><span class="line">  package: <span class="string">'egg-socket.io'</span>,</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h3 id="配置"><a class="markdown-anchor" href="#配置">#</a> 配置</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/config/config.${env}.js</span></span><br/><span class="line">exports.io = {</span><br/><span class="line">  init: { }, <span class="comment">// passed to engine.io</span></span><br/><span class="line">  namespace: {</span><br/><span class="line">    <span class="string">'/'</span>: {</span><br/><span class="line">      connectionMiddleware: [],</span><br/><span class="line">      packetMiddleware: [],</span><br/><span class="line">    },</span><br/><span class="line">    <span class="string">'/example'</span>: {</span><br/><span class="line">      connectionMiddleware: [],</span><br/><span class="line">      packetMiddleware: [],</span><br/><span class="line">    },</span><br/><span class="line">  },</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<blockquote>
<p>命名空间为 <code>/</code> 与 <code>/example</code>, 不是 <code>example</code></p>
</blockquote>
<p><strong>uws:</strong></p>
<p>如果想要使用 <a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">uws</a> 替代默认的 <code>ws</code> 可以做如下配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/config/config.${env}.js</span></span><br/><span class="line">exports.io = {</span><br/><span class="line">  init: { <span class="attr">wsEngine</span>: <span class="string">'uws'</span> }, <span class="comment">// default: ws</span></span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<blockquote>
<p>已知默认 <code>wsEngine</code> 在 <code>Chrome</code> 浏览器中断开连接存在异常，建议优先使用 <a href="https://github.com/uWebSockets/uWebSockets" target="_blank" rel="noopener">uws</a></p>
</blockquote>
<p><strong>redis:</strong></p>
<p><a href="https://github.com/eggjs/egg-socket.io" target="_blank" rel="noopener">egg-socket.io</a> 内置了 <code>socket.io-redis</code>，在 cluster 模式下，使用 redis 可以较为简单的实现 clients/rooms 等信息共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/config/config.${env}.js</span></span><br/><span class="line">exports.io = {</span><br/><span class="line">  redis: {</span><br/><span class="line">    host: { redis server host },</span><br/><span class="line">    port: { redis server prot },</span><br/><span class="line">    auth_pass: { redis server password },</span><br/><span class="line">    db: <span class="number">0</span>,</span><br/><span class="line">  },</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<blockquote>
<p>开启 <code>redis</code> 后，程序在启动时会尝试连接到 redis 服务器
此处 <code>redis</code> 仅用于存储连接实例信息，参见 <a href="https://socket.io/docs/server-api/#server-adapter-value" target="_blank" rel="noopener">#server.adapter</a></p>
</blockquote>
<p><strong>注意：</strong>
如果项目中同时使用了 <code>egg-redis</code>， 请单独配置，不可共用。</p>
<h3 id="部署"><a class="markdown-anchor" href="#部署">#</a> 部署</h3>
<p>框架是以 Cluster 方式启动的，而 socket.io 协议实现需要 sticky 特性支持，否则在多进程模式下无法正常工作。</p>
<p>由于 <a href="https://socket.io" target="_blank" rel="noopener">socket.io</a> 的设计，在多进程中服务器必须在 <code>sticky</code> 模式下工作，故需要给 startCluster 传递 sticky 参数。</p>
<p>修改 <code>package.json</code> 中 <code>npm scripts</code> 脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">{</span><br/><span class="line">  "scripts": {</span><br/><span class="line">    "dev": "egg-bin dev --sticky",</span><br/><span class="line">    "start": "egg-scripts start --sticky"</span><br/><span class="line">  }</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p><strong>Nginx 配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / {</span><br/><span class="line">  proxy_set_header Upgrade $http_upgrade;</span><br/><span class="line">  proxy_set_header Connection "upgrade";</span><br/><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br/><span class="line">  proxy_set_header Host $host;</span><br/><span class="line">  proxy_pass   http://127.0.0.1:7001;</span><br/><span class="line"/><br/><span class="line">  # http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind</span><br/><span class="line">  # proxy_bind       $remote_addr transparent;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<h2 id="使用-egg-socketio"><a class="markdown-anchor" href="#使用-egg-socketio">#</a> 使用 egg-socket.io</h2>
<p>开启 <a href="https://github.com/eggjs/egg-socket.io" target="_blank" rel="noopener">egg-socket.io</a> 的项目目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chat</span><br/><span class="line">├── app</span><br/><span class="line">│   ├── extend</span><br/><span class="line">│   │   └── helper.js</span><br/><span class="line">│   ├── io</span><br/><span class="line">│   │   ├── controller</span><br/><span class="line">│   │   │   └── default.js</span><br/><span class="line">│   │   └── middleware</span><br/><span class="line">│   │       ├── connection.js</span><br/><span class="line">│   │       └── packet.js</span><br/><span class="line">│   └── router.js</span><br/><span class="line">├── config</span><br/><span class="line">└── package.json</span><br/></pre></td></tr></table></figure>
<blockquote>
<p>注意：对应的文件都在 app/io 目录下</p>
</blockquote>
<h3 id="middleware"><a class="markdown-anchor" href="#middleware">#</a> Middleware</h3>
<p>中间件有如下两种场景：</p>
<ul>
<li>Connection</li>
<li>Packet</li>
</ul>
<p>其配置于各个命名空间下，根据上述两种场景分别发生作用。</p>
<p><strong>注意：</strong></p>
<p>如果我们启用了框架中间件，则会发现项目中有以下目录：</p>
<ul>
<li><code>app/middleware</code>：框架中间件</li>
<li><code>app/io/middleware</code>：插件中间件</li>
</ul>
<p>区别：</p>
<ul>
<li>框架中间件基于 http 模型设计，处理 http 请求。</li>
<li>插件中间件基于 socket 模型设计，处理 socket.io 请求。</li>
</ul>
<p>虽然框架通过插件尽量统一了它们的风格，但务必注意，它们的使用场景是不一样的。详情参见 issue：<a href="https://github.com/eggjs/egg/issues/1416" target="_blank" rel="noopener">#1416</a></p>
<h4 id="connection"><a class="markdown-anchor" href="#connection">#</a> Connection</h4>
<p>在每一个客户端连接或者退出时发生作用，故而我们通常在这一步进行授权认证，对认证失败的客户端做出相应的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/io/middleware/connection.js</span></span><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; {</span><br/><span class="line">    ctx.socket.emit(<span class="string">'res'</span>, <span class="string">'connected!'</span>);</span><br/><span class="line">    <span class="keyword">await</span> next();</span><br/><span class="line">    <span class="comment">// execute when disconnect.</span></span><br/><span class="line">    <span class="built_in">console</span>.log(<span class="string">'disconnection!'</span>);</span><br/><span class="line">  };</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>踢出用户示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tick = <span class="function">(<span class="params">id, msg</span>) =&gt;</span> {</span><br/><span class="line">  logger.debug(<span class="string">'#tick'</span>, id, msg);</span><br/><span class="line">  socket.emit(id, msg);</span><br/><span class="line">  app.io.of(<span class="string">'/'</span>).adapter.remoteDisconnect(id, <span class="literal">true</span>, err =&gt; {</span><br/><span class="line">    logger.error(err);</span><br/><span class="line">  });</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>同时，针对当前的连接也可以简单处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/io/middleware/connection.js</span></span><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; {</span><br/><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) {</span><br/><span class="line">      ctx.socket.disconnet();</span><br/><span class="line">      <span class="keyword">return</span>;</span><br/><span class="line">    }</span><br/><span class="line">    <span class="keyword">await</span> next();</span><br/><span class="line">    <span class="built_in">console</span>.log(<span class="string">'disconnection!'</span>);</span><br/><span class="line">  };</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h4 id="packet"><a class="markdown-anchor" href="#packet">#</a> Packet</h4>
<p>作用于每一个数据包（每一条消息）；在生产环境中，通常用于对消息做预处理，又或者是对加密消息的解密等操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/io/middleware/packet.js</span></span><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; {</span><br/><span class="line">    ctx.socket.emit(<span class="string">'res'</span>, <span class="string">'packet received!'</span>);</span><br/><span class="line">    <span class="built_in">console</span>.log(<span class="string">'packet:'</span>, <span class="keyword">this</span>.packet);</span><br/><span class="line">    <span class="keyword">await</span> next();</span><br/><span class="line">  };</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h3 id="controller"><a class="markdown-anchor" href="#controller">#</a> Controller</h3>
<p>Controller 对客户端发送的 event 进行处理；由于其继承于 <code>egg.Contoller</code>, 拥有如下成员对象:</p>
<ul>
<li>ctx</li>
<li>app</li>
<li>service</li>
<li>config</li>
<li>logger</li>
</ul>
<blockquote>
<p>详情参考 <a href="../basics/controller.html">Controller</a> 文档</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/io/controller/default.js</span></span><br/><span class="line"><span class="meta">'use strict'</span>;</span><br/><span class="line"/><br/><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br/><span class="line"/><br/><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>{</span><br/><span class="line">  <span class="keyword">async</span> ping() {</span><br/><span class="line">    <span class="keyword">const</span> { ctx, app } = <span class="keyword">this</span>;</span><br/><span class="line">    <span class="keyword">const</span> message = ctx.args[<span class="number">0</span>];</span><br/><span class="line">    <span class="keyword">await</span> ctx.socket.emit(<span class="string">'res'</span>, <span class="string">`Hi! I've got your message: <span class="subst">${message}</span>`</span>);</span><br/><span class="line">  }</span><br/><span class="line">}</span><br/><span class="line"/><br/><span class="line"><span class="built_in">module</span>.exports = DefaultController;</span><br/><span class="line"/><br/><span class="line"><span class="comment">// or async functions</span></span><br/><span class="line"/><br/><span class="line">exports.ping = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"/>) </span>{</span><br/><span class="line">  <span class="keyword">const</span> message = <span class="keyword">this</span>.args[<span class="number">0</span>];</span><br/><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.socket.emit(<span class="string">'res'</span>, <span class="string">`Hi! I've got your message: <span class="subst">${message}</span>`</span>);</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h3 id="router"><a class="markdown-anchor" href="#router">#</a> Router</h3>
<p>路由负责将 socket 连接的不同 events 分发到对应的 controller，框架统一了其使用方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/router.js</span></span><br/><span class="line"/><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">const</span> { router, controller, io } = app;</span><br/><span class="line"/><br/><span class="line">  <span class="comment">// default</span></span><br/><span class="line">  router.get(<span class="string">'/'</span>, controller.home.index);</span><br/><span class="line"/><br/><span class="line">  <span class="comment">// socket.io</span></span><br/><span class="line">  io.of(<span class="string">'/'</span>).route(<span class="string">'server'</span>, io.controller.home.server);</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>nsp 有如下的系统事件:</p>
<ul>
<li><code>disconnecting</code> doing the disconnect</li>
<li><code>disconnect</code> connection has disconnected.</li>
<li><code>error</code> Error occurred</li>
</ul>
<h3 id="namespaceroom"><a class="markdown-anchor" href="#namespaceroom">#</a> Namespace/Room</h3>
<h4 id="namespace-nsp"><a class="markdown-anchor" href="#namespace-nsp">#</a> Namespace (nsp)</h4>
<p>namespace 通常意味分配到不同的接入点或者路径，如果客户端没有指定 nsp，则默认分配到 "/" 这个默认的命名空间。</p>
<p>在 socket.io 中我们通过 <code>of</code> 来划分命名空间；鉴于 nsp 通常是预定义且相对固定的存在，框架将其进行了封装，采用配置的方式来划分不同的命名空间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket.io</span></span><br/><span class="line"><span class="keyword">var</span> nsp = io.of(<span class="string">'/my-namespace'</span>);</span><br/><span class="line">nsp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>{</span><br/><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected'</span>);</span><br/><span class="line">});</span><br/><span class="line">nsp.emit(<span class="string">'hi'</span>, <span class="string">'everyone!'</span>);</span><br/><span class="line"/><br/><span class="line"><span class="comment">// egg</span></span><br/><span class="line">exports.io = {</span><br/><span class="line">  namespace: {</span><br/><span class="line">    <span class="string">'/'</span>: {</span><br/><span class="line">      connectionMiddleware: [],</span><br/><span class="line">      packetMiddleware: [],</span><br/><span class="line">    },</span><br/><span class="line">  },</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h4 id="room"><a class="markdown-anchor" href="#room">#</a> Room</h4>
<p>room 存在于 nsp 中，通过 join/leave 方法来加入或者离开; 框架中使用方法相同；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> room = <span class="string">'default_room'</span>;</span><br/><span class="line"/><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; {</span><br/><span class="line">    ctx.socket.join(room);</span><br/><span class="line">    ctx.app.io.of(<span class="string">'/'</span>).to(room).emit(<span class="string">'online'</span>, { <span class="attr">msg</span>: <span class="string">'welcome'</span>, <span class="attr">id</span>: ctx.socket.id });</span><br/><span class="line">    <span class="keyword">await</span> next();</span><br/><span class="line">    <span class="built_in">console</span>.log(<span class="string">'disconnection!'</span>);</span><br/><span class="line">  };</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p><strong>注意：</strong> 每一个 socket 连接都会拥有一个随机且不可预测的唯一 id <code>Socket#id</code>，并且会自动加入到以这个 <code>id</code> 命名的 room 中</p>
<h2 id="实例"><a class="markdown-anchor" href="#实例">#</a> 实例</h2>
<p>这里我们使用 <a href="https://github.com/eggjs/egg-socket.io" target="_blank" rel="noopener">egg-socket.io</a> 来做一个支持 p2p 聊天的小例子</p>
<h3 id="client"><a class="markdown-anchor" href="#client">#</a> client</h3>
<p>UI 相关的内容不重复写了，通过 window.socket 调用即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// browser</span></span><br/><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br/><span class="line"/><br/><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"/>) </span>{</span><br/><span class="line">  <span class="comment">// init</span></span><br/><span class="line">  <span class="keyword">const</span> socket = io(<span class="string">'/'</span>, {</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 实际使用中可以在这里传递参数</span></span><br/><span class="line">    query: {</span><br/><span class="line">      room: <span class="string">'demo'</span>,</span><br/><span class="line">      userId: <span class="string">`client_<span class="subst">${<span class="built_in">Math</span>.random()}</span>`</span>,</span><br/><span class="line">    },</span><br/><span class="line"/><br/><span class="line">    transports: [<span class="string">'websocket'</span>]</span><br/><span class="line">  });</span><br/><span class="line"/><br/><span class="line">  socket.on(<span class="string">'connect'</span>, () =&gt; {</span><br/><span class="line">    <span class="keyword">const</span> id = socket.id;</span><br/><span class="line"/><br/><span class="line">    log(<span class="string">'#connect,'</span>, id, socket);</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 监听自身 id 以实现 p2p 通讯</span></span><br/><span class="line">    socket.on(id, msg =&gt; {</span><br/><span class="line">      log(<span class="string">'#receive,'</span>, msg);</span><br/><span class="line">    });</span><br/><span class="line">  });</span><br/><span class="line"/><br/><span class="line">  <span class="comment">// 接收在线用户信息</span></span><br/><span class="line">  socket.on(<span class="string">'online'</span>, msg =&gt; {</span><br/><span class="line">    log(<span class="string">'#online,'</span>, msg);</span><br/><span class="line">  });</span><br/><span class="line"/><br/><span class="line">  <span class="comment">// 系统事件</span></span><br/><span class="line">  socket.on(<span class="string">'disconnect'</span>, msg =&gt; {</span><br/><span class="line">    log(<span class="string">'#disconnect'</span>, msg);</span><br/><span class="line">  });</span><br/><span class="line"/><br/><span class="line">  socket.on(<span class="string">'disconnecting'</span>, () =&gt; {</span><br/><span class="line">    log(<span class="string">'#disconnecting'</span>);</span><br/><span class="line">  });</span><br/><span class="line"/><br/><span class="line">  socket.on(<span class="string">'error'</span>, () =&gt; {</span><br/><span class="line">    log(<span class="string">'#error'</span>);</span><br/><span class="line">  });</span><br/><span class="line"/><br/><span class="line">  <span class="built_in">window</span>.socket = socket;</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h4 id="微信小程序"><a class="markdown-anchor" href="#微信小程序">#</a> 微信小程序</h4>
<p>微信小程序提供的 API 为 WebSocket ，而 socket.io 是 Websocket 的上层封装，故我们无法直接用小程序的 API 连接，可以使用类似 <a href="https://github.com/wxsocketio/weapp.socket.io" target="_blank" rel="noopener">weapp.socket.io</a> 的库来适配。</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小程序端示例代码</span></span><br/><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'./yout_path/weapp.socket.io.js'</span>)</span><br/><span class="line"/><br/><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'http://localhost:8000'</span>)</span><br/><span class="line"/><br/><span class="line">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"/>) </span>{</span><br/><span class="line">  <span class="built_in">console</span>.log(<span class="string">'connected'</span>)</span><br/><span class="line">});</span><br/><span class="line"/><br/><span class="line">socket.on(<span class="string">'news'</span>, d =&gt; {</span><br/><span class="line">  <span class="built_in">console</span>.log(<span class="string">'received news: '</span>, d)</span><br/><span class="line">})</span><br/><span class="line"/><br/><span class="line">socket.emit(<span class="string">'news'</span>, {</span><br/><span class="line">  title: <span class="string">'this is a news'</span></span><br/><span class="line">})</span><br/></pre></td></tr></table></figure>
<h3 id="server"><a class="markdown-anchor" href="#server">#</a> server</h3>
<p>以下是 demo 的部分代码并解释了各个方法的作用</p>
<h4 id="config"><a class="markdown-anchor" href="#config">#</a> config</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/config/config.${env}.js</span></span><br/><span class="line">exports.io = {</span><br/><span class="line">  namespace: {</span><br/><span class="line">    <span class="string">'/'</span>: {</span><br/><span class="line">      connectionMiddleware: [ <span class="string">'auth'</span> ],</span><br/><span class="line">      packetMiddleware: [ ], <span class="comment">// 针对消息的处理暂时不实现</span></span><br/><span class="line">    },</span><br/><span class="line">  },</span><br/><span class="line"/><br/><span class="line">  <span class="comment">// cluster 模式下，通过 redis 实现数据共享</span></span><br/><span class="line">  redis: {</span><br/><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br/><span class="line">    port: <span class="number">6379</span>,</span><br/><span class="line">  },</span><br/><span class="line">};</span><br/><span class="line"/><br/><span class="line"><span class="comment">// 可选</span></span><br/><span class="line">exports.redis = {</span><br/><span class="line">  client: {</span><br/><span class="line">    port: <span class="number">6379</span>,</span><br/><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br/><span class="line">    password: <span class="string">''</span>,</span><br/><span class="line">    db: <span class="number">0</span>,</span><br/><span class="line">  },</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h4 id="helper"><a class="markdown-anchor" href="#helper">#</a> helper</h4>
<p>框架扩展用于封装数据格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/extend/helper.js</span></span><br/><span class="line"/><br/><span class="line"><span class="built_in">module</span>.exports = {</span><br/><span class="line">  parseMsg(action, payload = {}, metadata = {}) {</span><br/><span class="line">    <span class="keyword">const</span> meta = <span class="built_in">Object</span>.assign({}, {</span><br/><span class="line">      timestamp: <span class="built_in">Date</span>.now(),</span><br/><span class="line">    }, metadata);</span><br/><span class="line"/><br/><span class="line">    <span class="keyword">return</span> {</span><br/><span class="line">      meta,</span><br/><span class="line">      data: {</span><br/><span class="line">        action,</span><br/><span class="line">        payload,</span><br/><span class="line">      },</span><br/><span class="line">    };</span><br/><span class="line">  },</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>Format：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">{</span><br/><span class="line">  data: {</span><br/><span class="line">    action: <span class="string">'exchange'</span>,  <span class="comment">// 'deny' || 'exchange' || 'broadcast'</span></span><br/><span class="line">    payload: {},</span><br/><span class="line">  },</span><br/><span class="line">  meta:{</span><br/><span class="line">    timestamp: <span class="number">1512116201597</span>,</span><br/><span class="line">    client: <span class="string">'nNx88r1c5WuHf9XuAAAB'</span>,</span><br/><span class="line">    target: <span class="string">'nNx88r1c5WuHf9XuAAAB'</span></span><br/><span class="line">  },</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<h4 id="middleware-2"><a class="markdown-anchor" href="#middleware-2">#</a> middleware</h4>
<p><a href="https://github.com/eggjs/egg-socket.io" target="_blank" rel="noopener">egg-socket.io</a> 中间件负责 socket 连接的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/io/middleware/auth.js</span></span><br/><span class="line"/><br/><span class="line"><span class="keyword">const</span> PREFIX = <span class="string">'room'</span>;</span><br/><span class="line"/><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; {</span><br/><span class="line">    <span class="keyword">const</span> { app, socket, logger, helper } = ctx;</span><br/><span class="line">    <span class="keyword">const</span> id = socket.id;</span><br/><span class="line">    <span class="keyword">const</span> nsp = app.io.of(<span class="string">'/'</span>);</span><br/><span class="line">    <span class="keyword">const</span> query = socket.handshake.query;</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 用户信息</span></span><br/><span class="line">    <span class="keyword">const</span> { room, userId } = query;</span><br/><span class="line">    <span class="keyword">const</span> rooms = [ room ];</span><br/><span class="line"/><br/><span class="line">    logger.debug(<span class="string">'#user_info'</span>, id, room, userId);</span><br/><span class="line"/><br/><span class="line">    <span class="keyword">const</span> tick = <span class="function">(<span class="params">id, msg</span>) =&gt;</span> {</span><br/><span class="line">      logger.debug(<span class="string">'#tick'</span>, id, msg);</span><br/><span class="line"/><br/><span class="line">      <span class="comment">// 踢出用户前发送消息</span></span><br/><span class="line">      socket.emit(id, helper.parseMsg(<span class="string">'deny'</span>, msg));</span><br/><span class="line"/><br/><span class="line">      <span class="comment">// 调用 adapter 方法踢出用户，客户端触发 disconnect 事件</span></span><br/><span class="line">      nsp.adapter.remoteDisconnect(id, <span class="literal">true</span>, err =&gt; {</span><br/><span class="line">        logger.error(err);</span><br/><span class="line">      });</span><br/><span class="line">    };</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 检查房间是否存在，不存在则踢出用户</span></span><br/><span class="line">    <span class="comment">// 备注：此处 app.redis 与插件无关，可用其他存储代替</span></span><br/><span class="line">    <span class="keyword">const</span> hasRoom = <span class="keyword">await</span> app.redis.get(<span class="string">`<span class="subst">${PREFIX}</span>:<span class="subst">${room}</span>`</span>);</span><br/><span class="line"/><br/><span class="line">    logger.debug(<span class="string">'#has_exist'</span>, hasRoom);</span><br/><span class="line"/><br/><span class="line">    <span class="keyword">if</span> (!hasRoom) {</span><br/><span class="line">      tick(id, {</span><br/><span class="line">        type: <span class="string">'deleted'</span>,</span><br/><span class="line">        message: <span class="string">'deleted, room has been deleted.'</span>,</span><br/><span class="line">      });</span><br/><span class="line">      <span class="keyword">return</span>;</span><br/><span class="line">    }</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 用户加入</span></span><br/><span class="line">    logger.debug(<span class="string">'#join'</span>, room);</span><br/><span class="line">    socket.join(room);</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 在线列表</span></span><br/><span class="line">    nsp.adapter.clients(rooms, (err, clients) =&gt; {</span><br/><span class="line">      logger.debug(<span class="string">'#online_join'</span>, clients);</span><br/><span class="line"/><br/><span class="line">      <span class="comment">// 更新在线用户列表</span></span><br/><span class="line">      nsp.to(room).emit(<span class="string">'online'</span>, {</span><br/><span class="line">        clients,</span><br/><span class="line">        action: <span class="string">'join'</span>,</span><br/><span class="line">        target: <span class="string">'participator'</span>,</span><br/><span class="line">        message: <span class="string">`User(<span class="subst">${id}</span>) joined.`</span>,</span><br/><span class="line">      });</span><br/><span class="line">    });</span><br/><span class="line"/><br/><span class="line">    <span class="keyword">await</span> next();</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 用户离开</span></span><br/><span class="line">    logger.debug(<span class="string">'#leave'</span>, room);</span><br/><span class="line"/><br/><span class="line">    <span class="comment">// 在线列表</span></span><br/><span class="line">    nsp.adapter.clients(rooms, (err, clients) =&gt; {</span><br/><span class="line">      logger.debug(<span class="string">'#online_leave'</span>, clients);</span><br/><span class="line"/><br/><span class="line">      <span class="comment">// 获取 client 信息</span></span><br/><span class="line">      <span class="comment">// const clientsDetail = {};</span></span><br/><span class="line">      <span class="comment">// clients.forEach(client =&gt; {</span></span><br/><span class="line">      <span class="comment">//   const _client = app.io.sockets.sockets[client];</span></span><br/><span class="line">      <span class="comment">//   const _query = _client.handshake.query;</span></span><br/><span class="line">      <span class="comment">//   clientsDetail[client] = _query;</span></span><br/><span class="line">      <span class="comment">// });</span></span><br/><span class="line"/><br/><span class="line">      <span class="comment">// 更新在线用户列表</span></span><br/><span class="line">      nsp.to(room).emit(<span class="string">'online'</span>, {</span><br/><span class="line">        clients,</span><br/><span class="line">        action: <span class="string">'leave'</span>,</span><br/><span class="line">        target: <span class="string">'participator'</span>,</span><br/><span class="line">        message: <span class="string">`User(<span class="subst">${id}</span>) leaved.`</span>,</span><br/><span class="line">      });</span><br/><span class="line">    });</span><br/><span class="line"/><br/><span class="line">  };</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<h4 id="controller-2"><a class="markdown-anchor" href="#controller-2">#</a> controller</h4>
<p>P2P 通信，通过 exchange 进行数据交换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/io/controller/nsp.js</span></span><br/><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br/><span class="line"/><br/><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NspController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>{</span><br/><span class="line">  <span class="keyword">async</span> exchange() {</span><br/><span class="line">    <span class="keyword">const</span> { ctx, app } = <span class="keyword">this</span>;</span><br/><span class="line">    <span class="keyword">const</span> nsp = app.io.of(<span class="string">'/'</span>);</span><br/><span class="line">    <span class="keyword">const</span> message = ctx.args[<span class="number">0</span>] || {};</span><br/><span class="line">    <span class="keyword">const</span> socket = ctx.socket;</span><br/><span class="line">    <span class="keyword">const</span> client = socket.id;</span><br/><span class="line"/><br/><span class="line">    <span class="keyword">try</span> {</span><br/><span class="line">      <span class="keyword">const</span> { target, payload } = message;</span><br/><span class="line">      <span class="keyword">if</span> (!target) <span class="keyword">return</span>;</span><br/><span class="line">      <span class="keyword">const</span> msg = ctx.helper.parseMsg(<span class="string">'exchange'</span>, payload, { client, target });</span><br/><span class="line">      nsp.emit(target, msg);</span><br/><span class="line">    } <span class="keyword">catch</span> (error) {</span><br/><span class="line">      app.logger.error(error);</span><br/><span class="line">    }</span><br/><span class="line">  }</span><br/><span class="line">}</span><br/><span class="line"/><br/><span class="line"><span class="built_in">module</span>.exports = NspController;</span><br/></pre></td></tr></table></figure>
<h4 id="router-2"><a class="markdown-anchor" href="#router-2">#</a> router</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// {app_root}/app/router.js</span></span><br/><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> {</span><br/><span class="line">  <span class="keyword">const</span> { router, controller, io } = app;</span><br/><span class="line">  router.get(<span class="string">'/'</span>, controller.home.index);</span><br/><span class="line"/><br/><span class="line">  <span class="comment">// socket.io</span></span><br/><span class="line">  io.of(<span class="string">'/'</span>).route(<span class="string">'exchange'</span>, io.controller.nsp.exchange);</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>开两个 tab 页面，并调出控制台：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">socket.emit(<span class="string">'exchange'</span>, {</span><br/><span class="line">  target: <span class="string">'Dkn3UXSu8_jHvKBmAAHW'</span>,</span><br/><span class="line">  payload: {</span><br/><span class="line">    msg : <span class="string">'test'</span>,</span><br/><span class="line">  },</span><br/><span class="line">});</span><br/></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/eggjs/egg/master/docs/assets/socketio-console.png" alt=""/></p>
<h2 id="参考链接"><a class="markdown-anchor" href="#参考链接">#</a> 参考链接</h2>
<ul>
<li><a href="https://socket.io" target="_blank" rel="noopener">socket.io</a></li>
<li><a href="https://github.com/eggjs/egg-socket.io" target="_blank" rel="noopener">egg-socket.io</a></li>
<li><a href="https://github.com/eggjs/egg-socket.io/tree/master/example" target="_blank" rel="noopener">egg-socket.io example</a></li>
<li><a href="https://github.com/eggjs-community/demo-egg-socket.io" target="_blank" rel="noopener">egg-socket.io demo</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind" target="_blank" rel="noopener">nginx proxy_bind</a></li>
</ul>

  </article>
        </body>
    </html>